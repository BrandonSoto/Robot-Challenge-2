#pragma config(Sensor, S1,     leftColor,      sensorEV3_Color)
#pragma config(Sensor, S2,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     rightColor,     sensorEV3_Color)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// constants
#define DEFAULT_SPEED 50
#define STOPPED_SPEED 0
#define BASE_WALK_SPEED 15
#define MAX_SPEED_INCREASE 10
#define POST_COLLISION_SLEEP_TIME 500
#define MAX_TURN_TIME 1700
#define HALF_TURN_TIME 950
#define MIN_TURN_TIME 400
#define THINKING_TIME 2000
#define BUMPER_DETECTION_TIME 100
#define THREE_FEET_IN_CM 94
#define INCH 7

// threads
task sonarThread();
task wanderThread();

// functions
void setMotorSpeeds(int leftMotorSpeed, int rightMotorSpeed);
void biasedRandomWalk();
void randomPointTurn();

bool isWandering;
task main()
{
	isWandering = true;
	startTask(wanderThread);
	startTask(sonarThread);


	while (true){};
}

/*
 * Turns the robot in either direction using a point turn.
 * Robot will rotate a minimum of MIN_TURN_TIME and a maximum of
 * HALF_TURN_TIME.
 */
void randomPointTurn() {
	if (rand() % 2) //pivot left
		setMotorSpeeds(-DEFAULT_SPEED, DEFAULT_SPEED);
	else //pivot right
		setMotorSpeeds(DEFAULT_SPEED, -DEFAULT_SPEED);
	sleep(random(HALF_TURN_TIME - MIN_TURN_TIME) + MIN_TURN_TIME); //pivots for this long
	setMotorSpeeds(STOPPED_SPEED, STOPPED_SPEED);
}


task sonarThread() {
	// Distance to maintain to the target (30 cm)
//	const int distanceToMaintain = 30;

	float fDistance;

	while(true)
	{
		fDistance = getUSDistance(sonar);

		/*if ((int) fDistance <= INCH) {
		} else if ((int) fDistance <= THREE_FEET_IN_CM) {
		}*/

		// Object appears within range
		if ((int) fDistance <= THREE_FEET_IN_CM && INCH < (int) fDistance)
		{
			isWandering = false;
			stopTask(wanderThread);
			int speed = 89 - (84 - fDistance);

			setMotorSpeeds(speed, speed);
		}
		// Object is now close enough
		else if (INCH >= (int) fDistance) {
				isWandering = false;
				stopTask(wanderThread);
				setMotorSpeeds(0, 0);

				sleep(THINKING_TIME);
				backward(1,seconds, BASE_WALK_SPEED);

				randomPointTurn();
		} // else if line???
		// Done with the object, go back to wandering
		else if (!isWandering)
		{
				isWandering = true;
				startTask(wanderThread);
		}

	}
}

/*
 * Sets both left and right motor speeds.
 *
 * leftMotorSpeed: the speed of the left motor.
 * rightMotorSpeed: the speed of the right motor. */
void setMotorSpeeds(int leftMotorSpeed, int rightMotorSpeed) {
	setMotorSpeed(leftMotor, leftMotorSpeed);
	setMotorSpeed(rightMotor, rightMotorSpeed);
}

/*
 * Walks forward in a biased fashion. For both the left and the right motor, select a random speed that is between
 * BASE_WALK_SPEED and BASE_WALK_SPEED + MAX_SPEED_INCREASE.
 */
void biasedRandomWalk() {
	setMotorSpeeds(BASE_WALK_SPEED + random(MAX_SPEED_INCREASE), BASE_WALK_SPEED + random(MAX_SPEED_INCREASE));
}

task wanderThread() {
	int count = 0;

	while (true) {

		if(count > 50) {
			// If the biased random walk hasn't been updated in the last 50 iterations (500 milliseconds)
			biasedRandomWalk();
			count = 0;
		}

		sleep(10);
		count++;
	}
}
